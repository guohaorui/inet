[General]
network = AsynchronousShaperExample2

# enable IEEE 802.2 LLC layer
*.client*.llc.typename = "Ieee8022Llc"

# configure IEEE 802.2 LLC applications in clients
*.client*.numApps = 2
*.client*.app[*].typename = "Ieee8022LlcApp"
*.client*.app[0].source.packetNameFormat = "background-%c"
*.client*.app[1].source.packetNameFormat = "video-%c"
*.client*.app[*].io.interface = "eth0"
*.client*.app[*].io.remoteSap = 0
*.client*.app[0].io.remoteAddress = "server1"
*.client*.app[1].io.remoteAddress = "server2"

# configure background streams with ~40Mbps (33% overload)
*.client*.app[0].source.packetLength = 1000B
*.client*.app[0].source.productionInterval = truncnormal(150us, 100us)

# configure video streams with ~2Mbps (33% overload)
*.client*.app[1].source.packetLength = 500B
*.client*.app[1].source.productionInterval = truncnormal(1.5ms, 1ms)

# configure IEEE 802.2 LLC sink applications in servers
*.server*.numApps = 1
*.server*.app[0].typename = "Ieee8022LlcSink"
*.server*.app[0].io.localSap = 0

# disable ARP
**.arp.typename = "GlobalArp"

# disable IEEE 802.2 LLC in Ethernet switches
*.switch*.llc.typename = ""

# enable modular Ethernet protocol
*.*.ethernet.typename = "EthernetLayer"

# enable modular Ethernet interface
*.*.eth[*].typename = "LayeredEthernetInterface"
*.*.eth[*].bitrate = 100Mbps

# configure MAC address tables in switches
*.switch1.macTable.addressTable = [{address: "server1", interface: "eth2"},
                                   {address: "server2", interface: "eth2"}]
*.switch2.macTable.addressTable = [{address: "server1", interface: "eth0"},
                                   {address: "server2", interface: "eth1"}]

# enable modular bridging layer
*.switch*.bridging.typename = "BridgingLayer"

# enable stream encoding/decoding layer
*.switch*.bridging.streamCoder.typename = "StreamCoderLayer"
*.switch*.bridging.streamCoder.decoder.mapping = [{source: "client1", destination: "server1", stream: "c1_s1"},
                                                  {source: "client1", destination: "server2", stream: "c1_s2"},
                                                  {source: "client2", destination: "server1", stream: "c2_s1"},
                                                  {source: "client2", destination: "server2", stream: "c2_s2"}]

# enable per-stream filtering
*.switch*.bridging.streamFilter.typename = "StreamFilterLayer"
*.switch*.bridging.streamFilter.ingress.numStreams = 4
*.switch*.bridging.streamFilter.ingress.classifier.typename = "StreamClassifier"
*.switch*.bridging.streamFilter.ingress.classifier.mapping = {c1_s1: 0,
                                                              c2_s1: 1,
                                                              c1_s2: 2,
                                                              c2_s2: 3}

# configure per-stream metering
*.switch*.bridging.streamFilter.ingress.meter[*].typename = "EligibilityTimeMeter"
*.switch*.bridging.streamFilter.ingress.meter[0].comittedInformationRate = 40Mbps
*.switch*.bridging.streamFilter.ingress.meter[1].comittedInformationRate = 40Mbps
*.switch*.bridging.streamFilter.ingress.meter[2].comittedInformationRate = 2Mbps
*.switch*.bridging.streamFilter.ingress.meter[3].comittedInformationRate = 2Mbps
*.switch*.bridging.streamFilter.ingress.meter[*].comittedBurstSize = 10kB
*.switch*.bridging.streamFilter.ingress.meter[*].maxResidenceTime = 10ms

*.switch*.bridging.streamFilter.ingress.filter[*].typename = "EligibilityTimeFilter"

*.switch*.eth[*].macLayer.queue.typename = "GatingPriorityQueue"
*.switch*.eth[*].macLayer.queue.numQueues = 1
*.switch*.eth[*].macLayer.queue.classifier.typename = "PriorityClassifier"
*.switch*.eth[*].macLayer.queue.queue[*].typename = "EligibilityTimeQueue"
*.switch*.eth[*].macLayer.queue.gate[*].typename = "EligibilityTimeGate"
